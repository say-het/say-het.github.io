<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARQ Protocols Chat Application</title>
    <style>
* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(26, 26, 46, 0.95));
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .main-title {
            color: #8b9dff;
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(139, 157, 255, 0.5);
        }

        .subtitle {
            color: #a8b2d1;
            font-size: 14px;
        }

        .protocol-selector {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .protocol-btn {
            flex: 1;
            padding: 15px;
            background: rgba(30, 30, 50, 0.6);
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            color: #a8b2d1;
        }

        .protocol-btn:hover {
            border-color: #8b9dff;
            transform: translateY(-2px);
            background: rgba(139, 157, 255, 0.1);
            box-shadow: 0 5px 20px rgba(139, 157, 255, 0.3);
        }

        .protocol-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #8b9dff;
            box-shadow: 0 5px 25px rgba(139, 157, 255, 0.5);
        }

        .protocol-btn h3 {
            margin-bottom: 5px;
            font-size: 18px;
        }

        .protocol-btn p {
            font-size: 12px;
            opacity: 0.8;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(26, 26, 46, 0.95));
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        h2 {
            color: #b794f6;
            margin-bottom: 15px;
            font-size: 18px;
            text-shadow: 0 0 15px rgba(183, 148, 246, 0.4);
        }

        .info-text {
            color: #a8b2d1;
            font-size: 13px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        /* Chat Interface */
        .chat-users {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .user-section {
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 15px;
            background: rgba(15, 15, 35, 0.6);
        }

        .user-title {
            font-weight: bold;
            color: #8b9dff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .message-display {
            height: 200px;
            overflow-y: auto;
            background: rgba(10, 10, 25, 0.8);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .message {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .sent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
        }

        .received {
            background: rgba(139, 157, 255, 0.15);
            color: #c5d4ff;
            border: 1px solid rgba(139, 157, 255, 0.3);
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            font-size: 14px;
            background: rgba(10, 10, 25, 0.6);
            color: #c5d4ff;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #8b9dff;
            box-shadow: 0 0 15px rgba(139, 157, 255, 0.3);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:disabled {
            background: rgba(60, 60, 80, 0.5);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Visualization */
        .visualization {
            height: 350px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            position: relative;
            background: linear-gradient(to bottom, rgba(15, 15, 35, 0.8) 0%, rgba(20, 20, 40, 0.9) 100%);
            overflow: hidden;
            box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5);
        }

        .endpoint {
            position: absolute;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5), 0 0 30px rgba(102, 126, 234, 0.3);
            flex-direction: column;
            border: 2px solid rgba(139, 157, 255, 0.4);
        }

        .sender {
            top: 125px;
            left: 30px;
        }

        .receiver {
            top: 125px;
            right: 30px;
        }

        .window-display {
            font-size: 10px;
            margin-top: 5px;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 6px;
            border-radius: 4px;
        }

        .packet {
            position: absolute;
            width: 60px;
            height: 40px;
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 15px rgba(76, 175, 80, 0.6), 0 0 20px rgba(76, 175, 80, 0.4);
            transition: all 0.8s ease;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .ack {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            height: 30px;
            box-shadow: 0 2px 15px rgba(255, 152, 0, 0.6), 0 0 20px rgba(255, 152, 0, 0.4);
        }

        .lost {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            box-shadow: 0 2px 15px rgba(244, 67, 54, 0.6), 0 0 20px rgba(244, 67, 54, 0.4);
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 13px;
            color: #a8b2d1;
            font-weight: bold;
        }

        input[type="range"], input[type="number"] {
            width: 100%;
        }

        input[type="range"] {
            accent-color: #8b9dff;
        }

        input[type="number"] {
            padding: 8px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 25, 0.6);
            color: #c5d4ff;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #8b9dff;
            box-shadow: 0 0 15px rgba(139, 157, 255, 0.3);
        }

        .range-value {
            text-align: center;
            color: #8b9dff;
            font-weight: bold;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            margin: 8px 0;
            background: rgba(15, 15, 35, 0.6);
            border-radius: 8px;
            border-left: 4px solid #8b9dff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .status-label {
            font-weight: bold;
            color: #8b9dff;
        }

        .status-value {
            color: #a8b2d1;
            font-family: 'Courier New', monospace;
        }

        .log-window {
            height: 250px;
            overflow-y: auto;
            background: rgba(10, 10, 20, 0.95);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            margin-top: 15px;
            border: 1px solid rgba(0, 255, 0, 0.2);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(0, 255, 0, 0.1);
        }

        .log-entry {
            margin: 3px 0;
        }

        .log-timestamp {
            color: #666;
        }

        .log-error {
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .log-success {
            color: #51cf66;
            text-shadow: 0 0 10px rgba(81, 207, 102, 0.5);
        }

        .log-info {
            color: #74c0fc;
            text-shadow: 0 0 10px rgba(116, 192, 252, 0.5);
        }

        .buffer-display {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
            min-height: 50px;
            padding: 10px;
            background: rgba(10, 10, 25, 0.6);
            border-radius: 8px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }

        .buffer-slot {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            background: rgba(15, 15, 35, 0.6);
            color: #666;
        }

        .buffer-slot.filled {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            border-color: #4caf50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .buffer-slot.received {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            border-color: #2196f3;
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.5);
        }

        @media (max-width: 1400px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="main-title">üåê ARQ Protocols Chat Application</h1>
            <p class="subtitle">Interactive demonstration of Stop-and-Wait, Go-Back-N, and Selective Repeat protocols</p>
            
            <div class="protocol-selector">
                <div class="protocol-btn active" onclick="selectProtocol('stopwait')">
                    <h3>Stop and Wait</h3>
                    <p>Send one, wait for ACK</p>
                </div>
                <div class="protocol-btn" onclick="selectProtocol('gobackn')">
                    <h3>Go-Back-N</h3>
                    <p>Sliding window, retransmit all</p>
                </div>
                <div class="protocol-btn" onclick="selectProtocol('selectiverepeat')">
                    <h3>Selective Repeat</h3>
                    <p>Selective retransmission</p>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <!-- Chat Interface Panel -->
            <div class="panel">
                <h2>üí¨ Chat Application</h2>
                <p class="info-text" id="protocolDescription">Stop and Wait: Sender sends one packet and waits for ACK before sending the next.</p>
                
                <div class="chat-users">
                    <div class="user-section">
                        <div class="user-title">üë§ User A</div>
                        <div class="message-display" id="userAMessages"></div>
                        <div class="input-group">
                            <input type="text" id="userAInput" placeholder="Type message..." onkeypress="handleKeyPress(event, 'A')">
                            <button onclick="sendMessage('A')" id="sendBtnA">Send</button>
                        </div>
                    </div>

                    <div class="user-section">
                        <div class="user-title">üë§ User B</div>
                        <div class="message-display" id="userBMessages"></div>
                        <div class="input-group">
                            <input type="text" id="userBInput" placeholder="Type message..." onkeypress="handleKeyPress(event, 'B')">
                            <button onclick="sendMessage('B')" id="sendBtnB">Send</button>
                        </div>
                    </div>
                </div>

                <h2>üéÆ Protocol Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Packet Loss: <span class="range-value" id="lossValue">15%</span></label>
                        <input type="range" id="lossRate" min="0" max="100" value="15" oninput="updateLossRate(this.value)">
                    </div>
                    <div class="control-group">
                        <label>Delay: <span class="range-value" id="delayValue">800ms</span></label>
                        <input type="range" id="transmissionDelay" min="200" max="2000" value="800" step="100" oninput="updateDelay(this.value)">
                    </div>
                    <div class="control-group" id="windowSizeControl">
                        <label>Window Size:</label>
                        <input type="number" id="windowSize" min="1" max="8" value="4" onchange="updateWindowSize(this.value)">
                    </div>
                </div>

                <h2>üìä Sender Window</h2>
                <div class="buffer-display" id="senderWindow"></div>

                <h2>üì¶ Receiver Buffer</h2>
                <div class="buffer-display" id="receiverBuffer"></div>
            </div>

            <!-- Protocol Visualization Panel -->
            <div class="panel">
                <h2>üì° Protocol Visualization</h2>
                <p class="info-text">Watch packets and acknowledgments travel between sender and receiver</p>
                
                <div class="visualization" id="visualization">
                    <div class="endpoint sender">
                        <div>Sender</div>
                        <div class="window-display" id="senderInfo">Window: [0]</div>
                    </div>
                    <div class="endpoint receiver">
                        <div>Receiver</div>
                        <div class="window-display" id="receiverInfo">Expect: 0</div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div class="status-item">
                        <span class="status-label">Protocol State:</span>
                        <span class="status-value" id="protocolState">IDLE</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Packets Sent:</span>
                        <span class="status-value" id="packetsSent">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Packets Delivered:</span>
                        <span class="status-value" id="packetsDelivered">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Retransmissions:</span>
                        <span class="status-value" id="retransmissions">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Efficiency:</span>
                        <span class="status-value" id="efficiency">100%</span>
                    </div>
                </div>

                <h2 style="margin-top: 20px;">üìã Protocol Log</h2>
                <div class="log-window" id="logWindow"></div>
            </div>
        </div>
    </div>

    <script>
        // Base Protocol Class
        class ARQProtocol {
            constructor() {
                this.transmissionDelay = 800;
                this.packetLossRate = 0.15;
                this.stats = {
                    packetsSent: 0,
                    packetsDelivered: 0,
                    retransmissions: 0
                };
            }

            addLog(message, type = 'info') {
                const log = document.getElementById('logWindow');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }

            updateState(state) {
                document.getElementById('protocolState').textContent = state;
            }

            updateStats() {
                document.getElementById('packetsSent').textContent = this.stats.packetsSent;
                document.getElementById('packetsDelivered').textContent = this.stats.packetsDelivered;
                document.getElementById('retransmissions').textContent = this.stats.retransmissions;
                
                const total = this.stats.packetsSent + this.stats.retransmissions;
                const efficiency = total > 0 ? Math.round((this.stats.packetsDelivered / total) * 100) : 100;
                document.getElementById('efficiency').textContent = efficiency + '%';
            }

            visualizePacket(from, to, seqNum, lost, yOffset = 0) {
                return new Promise(resolve => {
                    const viz = document.getElementById('visualization');
                    const packet = document.createElement('div');
                    packet.className = 'packet' + (lost ? ' lost' : '');
                    packet.textContent = `${seqNum}`;
                    packet.style.top = (140 + yOffset) + 'px';
                    packet.style.left = from === 'A' ? '140px' : 'calc(100% - 200px)';
                    
                    viz.appendChild(packet);

                    setTimeout(() => {
                        const targetLeft = to === 'B' ? 'calc(100% - 200px)' : '140px';
                        packet.style.left = targetLeft;
                        
                        if (lost) {
                            packet.style.opacity = '0';
                            packet.style.transform = 'translateY(50px)';
                        }
                    }, 50);

                    setTimeout(() => {
                        viz.removeChild(packet);
                        resolve(!lost);
                    }, this.transmissionDelay);
                });
            }

            visualizeAck(from, to, ackNum, lost, yOffset = 0) {
                return new Promise(resolve => {
                    const viz = document.getElementById('visualization');
                    const ack = document.createElement('div');
                    ack.className = 'packet ack' + (lost ? ' lost' : '');
                    ack.textContent = `ACK${ackNum}`;
                    ack.style.top = (190 + yOffset) + 'px';
                    ack.style.left = from === 'B' ? 'calc(100% - 200px)' : '140px';
                    
                    viz.appendChild(ack);

                    setTimeout(() => {
                        const targetLeft = to === 'A' ? '140px' : 'calc(100% - 200px)';
                        ack.style.left = targetLeft;
                        
                        if (lost) {
                            ack.style.opacity = '0';
                            ack.style.transform = 'translateY(50px)';
                        }
                    }, 50);

                    setTimeout(() => {
                        viz.removeChild(ack);
                        resolve(!lost);
                    }, this.transmissionDelay);
                });
            }
        }

        // Stop and Wait Protocol
        class StopAndWaitProtocol extends ARQProtocol {
            constructor() {
                super();
                this.sequenceNumber = 0;
                this.expectedSeqNum = 0;
                this.waitingForAck = false;
                this.currentPacket = null;
                this.timeout = null;
            }

            async sendPacket(data, sender, receiver, onSuccess) {
                if (this.waitingForAck) {
                    this.addLog('Busy, waiting for ACK...', 'info');
                    return;
                }

                this.waitingForAck = true;
                this.currentPacket = { data, sender, receiver, onSuccess };
                this.updateSenderWindow();
                
                await this.transmitPacket(false);
            }

            async transmitPacket(isRetransmission) {
                const { data, sender, receiver, onSuccess } = this.currentPacket;
                
                if (isRetransmission) {
                    this.stats.retransmissions++;
                    this.addLog(`Retransmitting packet ${this.sequenceNumber}`, 'error');
                } else {
                    this.stats.packetsSent++;
                    this.addLog(`Sending packet ${this.sequenceNumber}: "${data}"`, 'info');
                }
                this.updateStats();

                const packetReceived = await this.visualizePacket(sender, receiver, this.sequenceNumber, Math.random() < this.packetLossRate);
                
                if (!packetReceived) {
                    this.addLog(`Packet ${this.sequenceNumber} lost!`, 'error');
                    this.startTimeout();
                    return;
                }

                this.addLog(`Packet ${this.sequenceNumber} received`, 'success');
                
                if (this.sequenceNumber === this.expectedSeqNum) {
                    this.stats.packetsDelivered++;
                    this.updateStats();
                    onSuccess(data);
                    this.expectedSeqNum = 1 - this.expectedSeqNum;
                }

                const ackReceived = await this.visualizeAck(receiver, sender, this.sequenceNumber, Math.random() < this.packetLossRate);
                
                if (!ackReceived) {
                    this.addLog(`ACK ${this.sequenceNumber} lost!`, 'error');
                    this.startTimeout();
                    return;
                }

                this.addLog(`ACK ${this.sequenceNumber} received`, 'success');
                clearTimeout(this.timeout);
                this.waitingForAck = false;
                this.sequenceNumber = 1 - this.sequenceNumber;
                this.updateSenderWindow();
                this.updateState('IDLE');
            }

            startTimeout() {
                clearTimeout(this.timeout);
                this.timeout = setTimeout(() => {
                    this.addLog('Timeout! Retransmitting...', 'error');
                    this.transmitPacket(true);
                }, 2000);
            }

            updateSenderWindow() {
                document.getElementById('senderInfo').textContent = `Seq: ${this.sequenceNumber}`;
                const windowDiv = document.getElementById('senderWindow');
                windowDiv.innerHTML = `<div class="buffer-slot ${this.waitingForAck ? 'filled' : ''}">${this.sequenceNumber}</div>`;
            }
        }

        // Go-Back-N Protocol
        class GoBackNProtocol extends ARQProtocol {
            constructor() {
                super();
                this.windowSize = 4;
                this.base = 0;
                this.nextSeqNum = 0;
                this.expectedSeqNum = 0;
                this.packets = [];
                this.timeout = null;
                this.isSending = false;
            }

            async sendPacket(data, sender, receiver, onSuccess) {
                if (this.nextSeqNum >= this.base + this.windowSize) {
                    this.addLog('Window full, waiting...', 'info');
                    return;
                }

                const seqNum = this.nextSeqNum++;
                this.packets[seqNum] = { data, sender, receiver, onSuccess, delivered: false };
                
                this.updateSenderWindow();
                
                if (!this.isSending) {
                    this.isSending = true;
                    await this.sendFromWindow();
                }
            }

            async sendFromWindow() {
                while (this.base < this.nextSeqNum && !this.timeout) {
                    const seqNum = this.base;
                    const packet = this.packets[seqNum];
                    
                    if (!packet) break;

                    this.stats.packetsSent++;
                    this.addLog(`Sending packet ${seqNum}: "${packet.data}"`, 'info');
                    this.updateStats();

                    const received = await this.visualizePacket(packet.sender, packet.receiver, seqNum, Math.random() < this.packetLossRate, (seqNum % 3) * 15);
                    
                    if (received) {
                        this.addLog(`Packet ${seqNum} received`, 'success');
                        
                        if (seqNum === this.expectedSeqNum) {
                            this.stats.packetsDelivered++;
                            this.updateStats();
                            packet.onSuccess(packet.data);
                            this.expectedSeqNum++;
                            this.updateReceiverInfo();
                        }

                        const ackReceived = await this.visualizeAck(packet.receiver, packet.sender, this.expectedSeqNum - 1, Math.random() < this.packetLossRate, (seqNum % 3) * 15);
                        
                        if (ackReceived) {
                            this.addLog(`ACK ${this.expectedSeqNum - 1} received (cumulative)`, 'success');
                            this.base = this.expectedSeqNum;
                            clearTimeout(this.timeout);
                            this.updateSenderWindow();
                        }
                    } else {
                        this.addLog(`Packet ${seqNum} lost! Going back to ${this.base}`, 'error');
                        await this.goBack();
                        break;
                    }
                }
                
                this.isSending = false;
                this.updateState('IDLE');
            }

            async goBack() {
                this.addLog(`Go-Back-N: Retransmitting from ${this.base}`, 'error');
                this.nextSeqNum = this.base;
                
                for (let i = this.base; i < this.base + this.windowSize && this.packets[i]; i++) {
                    this.stats.retransmissions++;
                }
                this.updateStats();
                
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.sendFromWindow();
            }

            updateSenderWindow() {
                document.getElementById('senderInfo').textContent = `Window: [${this.base}, ${this.base + this.windowSize - 1}]`;
                const windowDiv = document.getElementById('senderWindow');
                windowDiv.innerHTML = '';
                
                for (let i = this.base; i < this.base + this.windowSize; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'buffer-slot';
                    slot.textContent = i;
                    if (i < this.nextSeqNum) slot.classList.add('filled');
                    windowDiv.appendChild(slot);
                }
            }

            updateReceiverInfo() {
                document.getElementById('receiverInfo').textContent = `Expect: ${this.expectedSeqNum}`;
            }
        }

        // Selective Repeat Protocol
        class SelectiveRepeatProtocol extends ARQProtocol {
            constructor() {
                super();
                this.windowSize = 4;
                this.senderBase = 0;
                this.nextSeqNum = 0;
                this.receiverBase = 0;
                this.packets = [];
                this.receiverBuffer = {};
                this.acks = {};
                this.isSending = false;
            }

            async sendPacket(data, sender, receiver, onSuccess) {
                if (this.nextSeqNum >= this.senderBase + this.windowSize) {
                    this.addLog('Window full, waiting...', 'info');
                    return;
                }

                const seqNum = this.nextSeqNum++;
                this.packets[seqNum] = { data, sender, receiver, onSuccess, acked: false };
                
                this.updateSenderWindow();
                
                if (!this.isSending) {
                    this.isSending = true;
                    await this.sendPackets();
                }
            }

            async sendPackets() {
                const promises = [];
                
                for (let i = this.senderBase; i < this.nextSeqNum; i++) {
                    if (!this.packets[i].acked) {
                        promises.push(this.sendSinglePacket(i));
                    }
                }
                
                await Promise.all(promises);
                this.isSending = false;
                this.updateState('IDLE');
            }

            async sendSinglePacket(seqNum) {
                const packet = this.packets[seqNum];
                
                this.stats.packetsSent++;
                this.addLog(`Sending packet ${seqNum}: "${packet.data}"`, 'info');
                this.updateStats();

                const received = await this.visualizePacket(packet.sender, packet.receiver, seqNum, Math.random() < this.packetLossRate, (seqNum % 3) * 15);
                
                if (received) {
                    this.addLog(`Packet ${seqNum} received`, 'success');
                    this.receiverBuffer[seqNum] = packet;
                    this.updateReceiverBuffer();
                    
                    // Deliver in-order packets
                    while (this.receiverBuffer[this.receiverBase]) {
                        const pkt = this.receiverBuffer[this.receiverBase];
                        this.stats.packetsDelivered++;
                        this.updateStats();
                        pkt.onSuccess(pkt.data);
                        delete this.receiverBuffer[this.receiverBase];
                        this.receiverBase++;
                        this.updateReceiverInfo();
                    }

                    const ackReceived = await this.visualizeAck(packet.receiver, packet.sender, seqNum, Math.random() < this.packetLossRate, (seqNum % 3) * 15);
                    
                    if (ackReceived) {
                        this.addLog(`ACK ${seqNum} received (selective)`, 'success');
                        this.packets[seqNum].acked = true;
                        this.acks[seqNum] = true;
                        
                        // Slide window if base is acked
                        while (this.packets[this.senderBase] && this.packets[this.senderBase].acked) {
                            this.senderBase++;
                        }
                        this.updateSenderWindow();
                    }
                } else {
                    this.addLog(`Packet ${seqNum} lost! Will retransmit selectively`, 'error');
                    this.stats.retransmissions++;
                    this.updateStats();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    await this.sendSinglePacket(seqNum);
                }
            }

            updateSenderWindow() {
                document.getElementById('senderInfo').textContent = `Window: [${this.senderBase}, ${this.senderBase + this.windowSize - 1}]`;
                const windowDiv = document.getElementById('senderWindow');
                windowDiv.innerHTML = '';
                
                for (let i = this.senderBase; i < this.senderBase + this.windowSize; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'buffer-slot';
                    slot.textContent = i;
                    if (this.packets[i]) {
                        slot.classList.add(this.packets[i].acked ? 'received' : 'filled');
                    }
                    windowDiv.appendChild(slot);
                }
            }

            updateReceiverInfo() {
                document.getElementById('receiverInfo').textContent = `Expect: ${this.receiverBase}`;
            }

            updateReceiverBuffer() {
                const bufferDiv = document.getElementById('receiverBuffer');
                bufferDiv.innerHTML = '';
                
                for (let i = this.receiverBase; i < this.receiverBase + this.windowSize; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'buffer-slot';
                    slot.textContent = i;
                    if (this.receiverBuffer[i]) {
                        slot.classList.add('received');
                    }
                    bufferDiv.appendChild(slot);
                }
            }
        }

        // Global variables
        let currentProtocol = null;
        let currentProtocolType = 'stopwait';

        // Initialize protocol
        function initializeProtocol() {
            switch(currentProtocolType) {
                case 'stopwait':
                    currentProtocol = new StopAndWaitProtocol();
                    document.getElementById('windowSizeControl').style.display = 'none';
                    document.getElementById('protocolDescription').textContent = 
                        'Stop and Wait: Sender sends one packet and waits for ACK before sending the next.';
                    break;
                case 'gobackn':
                    currentProtocol = new GoBackNProtocol();
                    document.getElementById('windowSizeControl').style.display = 'flex';
                    document.getElementById('protocolDescription').textContent = 
                        'Go-Back-N: Uses sliding window. On error, retransmits all packets from the lost one onwards.';
                    break;
                case 'selectiverepeat':
                    currentProtocol = new SelectiveRepeatProtocol();
                    document.getElementById('windowSizeControl').style.display = 'flex';
                    document.getElementById('protocolDescription').textContent = 
                        'Selective Repeat: Uses sliding window. Only retransmits the packets that were lost or corrupted.';
                    break;
            }
            
            currentProtocol.transmissionDelay = parseInt(document.getElementById('transmissionDelay').value);
            currentProtocol.packetLossRate = parseFloat(document.getElementById('lossRate').value) / 100;
            
            if (currentProtocol.windowSize !== undefined) {
                currentProtocol.windowSize = parseInt(document.getElementById('windowSize').value);
            }
            
            currentProtocol.addLog(`${currentProtocolType.toUpperCase()} Protocol initialized`, 'success');
            currentProtocol.updateStats();
            
            if (currentProtocol.updateSenderWindow) currentProtocol.updateSenderWindow();
            if (currentProtocol.updateReceiverInfo) currentProtocol.updateReceiverInfo();
            if (currentProtocol.updateReceiverBuffer) currentProtocol.updateReceiverBuffer();
        }

        function selectProtocol(type) {
            currentProtocolType = type;
            
            // Update UI
            document.querySelectorAll('.protocol-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.protocol-btn').classList.add('active');
            
            // Clear displays
            document.getElementById('logWindow').innerHTML = '';
            document.getElementById('userAMessages').innerHTML = '';
            document.getElementById('userBMessages').innerHTML = '';
            document.getElementById('senderWindow').innerHTML = '';
            document.getElementById('receiverBuffer').innerHTML = '';
            
            // Initialize new protocol
            initializeProtocol();
        }

        // Chat functionality
        function sendMessage(user) {
            const input = document.getElementById(`user${user}Input`);
            const message = input.value.trim();
            
            if (!message) return;

            const sender = user;
            const receiver = user === 'A' ? 'B' : 'A';
            
            // Add message to sender's display
            addMessageToDisplay(sender, message, 'sent');
            
            // Send via protocol
            currentProtocol.sendPacket(message, sender, receiver, (data) => {
                // Add message to receiver's display
                addMessageToDisplay(receiver, data, 'received');
            });
            
            input.value = '';
        }

        function addMessageToDisplay(user, message, type) {
            const display = document.getElementById(`user${user}Messages`);
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = message;
            display.appendChild(msgDiv);
            display.scrollTop = display.scrollHeight;
        }

        function handleKeyPress(event, user) {
            if (event.key === 'Enter') {
                sendMessage(user);
            }
        }

        function updateLossRate(value) {
            document.getElementById('lossValue').textContent = value + '%';
            currentProtocol.packetLossRate = value / 100;
            currentProtocol.addLog(`Packet loss rate set to ${value}%`, 'info');
        }

        function updateDelay(value) {
            document.getElementById('delayValue').textContent = value + 'ms';
            currentProtocol.transmissionDelay = parseInt(value);
            currentProtocol.addLog(`Transmission delay set to ${value}ms`, 'info');
        }

        function updateWindowSize(value) {
            if (currentProtocol.windowSize !== undefined) {
                currentProtocol.windowSize = parseInt(value);
                currentProtocol.addLog(`Window size set to ${value}`, 'info');
                if (currentProtocol.updateSenderWindow) currentProtocol.updateSenderWindow();
                if (currentProtocol.updateReceiverBuffer) currentProtocol.updateReceiverBuffer();
            }
        }

        // Initialize on load
        window.onload = () => {
            initializeProtocol();
        };
    </script>
</body>
</html>